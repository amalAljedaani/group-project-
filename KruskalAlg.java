
package GraphFramework;

import java.util.*;


public class KruskalAlg extends MSTAlgorithm {

    private Graph graph;
    private Vertex[] parent;
    private Map<Vertex, Integer> indexMap; // Map to store index of each vertex in parent array

    // Constructor
    public KruskalAlg(Graph graph) {
        super(graph);
        this.graph = graph;
        this.parent = new Vertex[graph.verticesno];
        this.indexMap = new HashMap<>();
        for (int i = 0; i < graph.verticesno; i++) {
            Vertex v = graph.verticess.get(i);
            parent[i] = v;
            indexMap.put(v, i);
        }
        kruskal(); // Call Kruskal's algorithm to compute the MST
    }

    // Kruskal's algorithm implementation
    @Override
    public void kruskal() {
        // Initialize rank array for each vertex
        int[] rank = new int[graph.verticesno];
        for (int i = 0; i < graph.verticesno; i++) {
            rank[i] = 0;
        }

        
        // Create a list of all edges and sort them by weight
        List<Edge> sortedEdges = new ArrayList<>();
        
        for (int i = 0; i < graph.verticess.size(); i++) {
            sortedEdges.addAll(graph.verticess.get(i).adjLists);
        }
        Collections.sort(sortedEdges, Comparator.comparing(Edge::getWeight));

        // Iterate through sorted edges and perform union-find operations
        for (Edge edge : sortedEdges) {
            Vertex u = edge.source;
            Vertex v = edge.destination;
            // Find the roots of the sets containing u and v
            Vertex rootU = find(u);
            Vertex rootV = find(v);
            // If the vertices are not in the same set, union them and add the edge to the MST
            if (!rootU.equals(rootV)) {
                union(rootU, rootV, rank);
                MSTResultList.add(edge);
            }
        }
    }

    // Find operation with path compression
    private Vertex find(Vertex v) {
        int index = indexMap.get(v);
        if (parent[index].equals(v)) {
            return v;
        } else {
            parent[index] = find(parent[index]);
            return parent[index];
        }
    }

    // Union operation with rank-based merging
    private void union(Vertex u, Vertex v, int[] rank) {
        Vertex rootU = find(u);
        Vertex rootV = find(v);
        if (rank[indexMap.get(rootU)] < rank[indexMap.get(rootV)]) {
            parent[indexMap.get(rootU)] = rootV;
        } else if (rank[indexMap.get(rootV)] < rank[indexMap.get(rootU)]) {
            parent[indexMap.get(rootV)] = rootU;
        } else {
            parent[indexMap.get(rootU)] = rootV;
            rank[indexMap.get(rootV)]++;
        }
    }

    // Getter for the MST
    public List<Edge> getMST() {
        return MSTResultList;
    }

    // Display the resulting MST (Required by the MSTAlgorithm abstract class)
    @Override
    public void displayResultingMST() {
        System.out.println("The phone network (minimum spanning tree) generated by Kruskal algorithm is as follows:\n");
        int cost = 0;
        for (Edge e : MSTResultList) {
            e.display_info();
            cost += e.getWeight();
        }
        System.out.println("\nThe cost of designed phone network: " + cost + "\n");
    }
    
    @Override
    public void displayCost() {
        int cost = 0; // Initialize a variable to track the total cost of the MST
        // Loop through each edge in the MST result list
        for (Edge e : MSTResultList) {
            cost += e.getWeight();  // Add the weight of the edge to the total cost
        }
        // Print the total cost of the MST
        System.out.println("\nThe cost of designed phone network of Kruskal's Algorithm: " + cost + "\n");
}
}
    
